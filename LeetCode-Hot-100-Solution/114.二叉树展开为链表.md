### 114.二叉树展开为链表  

> 给你二叉树的根结点 root ，请你将它展开为一个单链表：  
> 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。  
> 展开后的单链表应该与二叉树 先序遍历 顺序相同。  
***
##### 解法一：迭代
> 思路：先序遍历（根->左->右），二叉树根节点的右节点应该是挂载在二叉树左子树先序遍历的最后一个节点上的，
> 这个节点就是二叉树左子树根节点的右子树的右子树...。采用迭代的想法，处理完二叉树的根节点后，二叉树的右子树是
> 原来的左子树的根节点，对这个节点采取一样的处理措施  
```c++
class Solution{
public:
    void flatten(TreeNode* root){
         TreeNode* curr = root;
         while(curr){
             if(curr->left){
                 TreeNode* node = curr->left;
                 while(node->right)
                    node = node->right;
                 node->right = curr->right;
                 curr->right = curr->left;
                 curr->left = nullptr;
             }
             curr = curr->right;
         }
    }
 };
```
##### 解法二：递归
```c++
class Solution{
private:
    TreeNode* flattenHelper(TreeNode* root){
        if(!root)   return nullptr;
        TreeNode* newLeft = flattenHelper(root->left);
        TreeNode* newRight = flattenHelper(root->right);
        if(!newLeft){ 
            root->right = newRight;
            return root;
        }
        TreeNode* pnl = newLeft;
        while(pnl->right)
            pnl=pnl->right;
        pnl->right = newRight;
        root->right = newLeft;
        root->left = nullptr;
        return root;
    }
public:
    void flatten(TreeNode* root){
         flattenHelper(root);
    }
 };
```
