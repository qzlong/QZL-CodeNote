### 11.盛最多水的容器
> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
> 说明：你不能倾斜容器。  
<img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="p1" height=60% width=60%>  

***
##### 解法一：枚举(会超时)
```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int capacity=0;
        for(int i=0;i<height.size()-1;++i){
            for(int j=i+1;j<height.size();++j){
                int h = min(height[i],height[j]);
                int w = j-i;
                capacity = max(h*w,capacity);
            }
        }
        return capacity;
    }
};
```
##### 解法二：双指针
> 思路：面积等于长乘高，高是两个height中的最小值，长是两个height的距离；如果长缩短，则高必须增加，面积才有可能增加。
> 一开始使用两个指针，分别指向头和尾，然后如果height[l]<height[r]，则移动左指针到下一个height>height[l]的位置，增加长方形面积的高。
> 右边短同理。结束条件是左指针比右指针大。  
> 为什么这样移动是对的？我们假设左指针长为x,右指针长为y，二者距离为t且x<y。则面积为x\*t,如果移动的是右指针，则无论如何都不能让
> 面积大于x\*t，因为如果高最大为x，而长在缩短。所以只能移动较短的那边，才有可能提高面积。
```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int l=0,r=height.size()-1;
        int capacity = min(height[l],height[r])*(r-l);
        while(l<r){
            if(height[l]<height[r]){
                int shorterLine = height[l];
                while(l<r&&height[l]<=shorterLine) ++l;
            }else{
                int shorterLine = height[r];
                while(l<r&&height[r]<=shorterLine) --r;
            }
            capacity = max(capacity,min(height[l],height[r])*(r-l));
        }
        return capacity;
    }
};
```
