### 399.除法求值
> 给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。
> 返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。  
> 注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。
***
解法一：并查集
> 思路：对于处理有传递性关系的问题，可以使用并查集。假设a/b=n，则表示a和b在同一个集合里，a向b有一条带权的有向边。如b/c=m，
> 表示b和c也在同一个集合里。同一个集合里的两个数即能求值。在并查集的底层，我们使用parent[i]表示i的直接父亲，用weight[i]表示
> i到直接父亲的权，也就是a/b=3，则parent[a]=b,weight[a]=3。为了方便操作，用一个哈希表把字符串映射成int型。  
> 具体可以查看[题解](https://leetcode-cn.com/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-nan-du-zhong-deng-286-w45d/) 
```c++
class Solution {
public:
    vector<double> calcEquation(vector<vector<string>>& equations, vector<double>& values, vector<vector<string>>& queries) {
        UnionFind unionFind(equations.size()*2);
        unordered_map<string,int> hashmap;
        int id = 0;
        //将字符串映射成int,方便实现
        for(int i=0;i<equations.size();i++){
            auto& e = equations[i];
            string s1 = e[0];
            string s2 = e[1];
            if(hashmap.find(s1)==hashmap.end()){
                hashmap[s1]=id++;
            }
            if(hashmap.find(s2)==hashmap.end()){
                hashmap[s2]=id++;
            }
            unionFind.unionXY(hashmap[s1],hashmap[s2],values[i]);
        }
        //查询求值
        vector<double> ret;
        for(int i=0;i<queries.size();++i){
            auto & query = queries[i];
            string& s1 = query[0];
            string& s2 = query[1];
            auto x = hashmap.find(s1);
            auto y = hashmap.find(s2);
            if(x==hashmap.end()||y==hashmap.end())
                ret.emplace_back(-1.0);
            else
                ret.emplace_back(unionFind.isConnect(hashmap[s1],hashmap[s2]));
        }
        return ret;
    }
private:
    class UnionFind{
    private:
        int * parent;
        double* weight;
    public:
        UnionFind(int n){
            parent = new int[n];
            weight = new double[n];
            for(int i=0;i<n;i++){
                parent[i]=i;
                weight[i]=1.0;
            }
        }
        ~UnionFind(){
            delete[] parent;
            delete[] weight;
        }
        void unionXY(int i,int j,double value){
            int x = find(i);
            int y = find(j);
            if(x==y)    return;
            parent[x]=y;
            weight[x]=value*weight[j]/weight[i];
        }
        int find(int i){
            if(i!=parent[i]){
                int orign = parent[i];
                parent[i]=find(parent[i]);
                weight[i]*=weight[orign];
            }
            return parent[i];
        }
        double isConnect(int x,int y){
            int rootX = find(x);
            int rootY = find(y);
            if(rootX!=rootY){
                return -1.0;
            }
            return weight[x]/weight[y];
        }

    };
};
```
