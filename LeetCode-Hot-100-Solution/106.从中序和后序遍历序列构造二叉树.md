### 106.从中序与后序遍历序列构造二叉树
> 根据一棵树的中序遍历和后序遍历构造二叉树
***
##### 解法一：递归
```c++
class Solution {
private:
    unordered_map<int,int> map;
    TreeNode* buildTree(const vector<int>&inorder,const vector<int>& postorder,int inorder_left,int inorder_right,int postorder_left,int postorder_right){
        if(inorder_left>inorder_right)  return nullptr;
        int root_node = postorder[postorder_right];
        int inorder_root_index = map[root_node];
        int left_tree_size = inorder_root_index-inorder_left;
        int right_tree_size = inorder_right-inorder_root_index;
        int new_postorder_right = postorder_right-1;
        TreeNode* root = new TreeNode(root_node);
        root->left = buildTree(inorder,postorder,inorder_left,inorder_root_index-1,postorder_left,postorder_left+left_tree_size-1);
        root->right = buildTree(inorder,postorder,inorder_root_index+1,inorder_right,new_postorder_right-right_tree_size+1,new_postorder_right);
        return root;
    }
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        int n=inorder.size();
        for(int i=0;i<n;i++)
            map[inorder[i]]=i;
        return buildTree(inorder,postorder,0,n-1,0,n-1);
    }
};
```
