##### 146.LRU缓存机制
> 运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。实现 LRUCache 类：  

> 1.  LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存  
> 2.  int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。  
> 3.  void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。  
***
##### 解法一：使用双向链表+哈希表实现LRU
> LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。  
> 双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。  
> 哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。  

```c++
struct DListNode{
    int key,value;
    DListNode* pre,*next;
    DListNode():key(0),value(0),pre(nullptr),next(nullptr){}
    DListNode(int _key,int _value):key(_key),value(_value),pre(nullptr),next(nullptr){}
};

class LRUCache {
private:
    int capacity,size;
    DListNode* head,*tail;
    unordered_map<int,DListNode*> cache;

public:
    LRUCache(int _capacity):capacity(_capacity),size(0){
        head = new DListNode();
        tail = new DListNode();
        head->next = tail;
        tail->pre = head;
    }
    
    int get(int key) {
        auto it = cache.find(key);
        if(it==cache.end()) return -1;
        DListNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        auto it = cache.find(key);
        if(it!=cache.end()){
            DListNode* node = cache[key];
            node->value = value;
            moveToHead(node);
            return;
        }else{
            DListNode* newNode = new DListNode(key,value);
            addToHead(newNode);
            cache[key] = newNode;
            ++size;
            if(size>capacity){
                auto node = removeTail();
                cache.erase(node->key);
                delete node;
                --size;
            }
                
        }
    }
private:
    void moveToHead(DListNode* p){
        removeNode(p);
        addToHead(p);
    }
    void removeNode(DListNode*p){
        p->pre->next = p->next;
        p->next->pre = p->pre;
    }
    void addToHead(DListNode*p){
        head->next->pre = p;
        p->pre = head;
        p->next = head->next;
        head->next = p;
    }
    DListNode* removeTail(){
        DListNode* t = tail->pre;
        tail->pre->pre->next=tail;
        tail->pre = tail->pre->pre;
        return t;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```
