### 75.颜色分类
> 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。  
> 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

***
##### 解法一：直接排序
```c++
class Solution { //直接排序
public:
    void sortColors(vector<int>& nums) {
        for(int i=0;i<nums.size();i++){
            for(int j=1;j<nums.size()-i;j++){
                if(nums[j-1]>nums[j]){
                    swap(nums[j-1],nums[j]);
                }
            }
        }
    }
};
```
##### 解法二：单指针
> 思路：遍历两次数组，第一次遍历把所有0都交换到数组的前面；
> 第二次遍历从上一次遍历的指针开始，再次遍历，把所有1都交换到紧随0后面的位置上
```c++
class Solution { //单指针
public:
    void sortColors(vector<int>& nums) {
        int ptr = 0;
        for(int i=0;i<nums.size();i++){
            if(nums[i]==0){
                swap(nums[i],nums[ptr++]);
            }
        }
        for(int i=ptr;i<nums.size();i++){
            if(nums[i]==1){
                swap(nums[i],nums[ptr++]);
            }
        }
    }
};
```
##### 解法三：双指针
> 思路：用p0和p1来交换0和1，用i遍历。如果是1，则交换nums[i]和nums[p1]，如果是0，则交换nums[i]和nums[p0]；
> 注意当p0<p1时，表示p0交换出去的是1，需要再把nums[i]和nums[p1]进行交换，交换完毕后二者的指针都需要移动
```c++
class Solution { //双指针
public:
    void sortColors(vector<int>& nums) {
        int p0 = 0,p1 = 0 ;
        for(int i=0;i<nums.size();++i){
            if(nums[i]==1)
                swap(nums[i],nums[p1++]);
            else if(nums[i]==0){
                swap(nums[i],nums[p0]);
                if(p0<p1)
                    swap(nums[i],nums[p1]);
                ++p0;
                ++p1;
            }
        }
    }
};
```
