### 239.滑动窗口的最大值
> 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
> 你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。
***
##### 解法一：优先对列
> 思路：建立一个大根堆，元素类型为pair，first保存值，second保存左边，second用来判断值是否过期（必须在窗口内）
```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        priority_queue<pair<int,int>> q;
        for(int i=0;i<k;++i)
            q.emplace(nums[i],i);
        vector<int> ret{q.top().first};
        for(int i=k;i<nums.size();++i){
            q.emplace(nums[i],i);
            while(q.top().second<=i-k)
                q.pop();
            ret.emplace_back(q.top().first);
        }
        return ret;
    }
};
```
##### 解法二：单调对列
> 思路：与单调栈类似，但是获取元素是从对列前端获取。  
> 值得注意的是，单调栈和单调队列保存元素的坐标会更容易使用（相较于保存元素的值）
```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> q;
        for(int i=0;i<k;i++){
            while(!q.empty()&&nums[i]>nums[q.back()]){
                q.pop_back();
            }
            q.push_back(i);
        }
        vector<int> ret{nums[q.front()]};
        for(int i=k;i<nums.size();++i){
            while(!q.empty()&&nums[i]>nums[q.back()]){
                q.pop_back();
            }
            q.push_back(i);
            while(q.front()<=i-k){
                q.pop_front();
            }
            ret.push_back(nums[q.front()]);
        }
        return ret;
    }
};
```
