### 287.寻找重复数
> 给定一个包含n+1个整数的数组nums，其数字都在1到n之间（包括1和n），可知至少存在一个重复的整数  
> 假设nums只有一个重复的整数，找出这个重复的数
***
### 解法一：
> 思路：由于题目保证有一个重复的数，因此可以尝试把值为m的数放回nums[m]中，如果nums[m]刚好等于m，证明m是重复的，否则交换m和
> nums[m]的值，然后继续搜索，直到出现nums[m]==m的情况  
```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int v = nums[0];
        while(true){
            if(nums[v]==v) return v;
            else swap(v,nums[v]);
        }
    }
};
```
### 解法二：
> 将数组看作链表，数组的值看成指向下一个数的指针。则题目条件保证了链表中有环。
> 现在要找的就是环的起点。具体的做法就是设置慢指针slow和快指针fast，慢指针每次走一步，快指针每次走两步，两个指针
> 在有环的情况下一定会相遇，此时我们将slow放置在起点，然后两个指针每次同时移动一步，则相遇点就是起点。  
> 为什么这样是正确的？假设环长为L，从起点到环的入口的步数为a，从环的入口继续走b步到达相遇位置，从相遇位置继续走c步回到环的入口，
> 则有b+c=L。慢指针走了a+b步时，快指针走了2（a+b）步，从另一个角度看，在相遇处快指针比慢指针多走了kL步，也就是a+b+kL=2（a+b）
> ，a=kL-b=（k-1）L+（L-b）=(k-1)L+c。由此可知，slow从起点出发，再走a步，fast刚好走了kL+c步，由于原来的相遇点距离
> 相交点为c，所以两者会在c点相遇。
```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int slow = 0, fast = 0;
        do {
            slow = nums[slow];
            fast = nums[nums[fast]];
        } while (slow != fast);
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};
```
