### 48.旋转图像
> 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。
> 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。
<img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg"  height=50% width=50% alt="p1">
<img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg"  height=50% width=50% alt="p2">  

***  

##### 解法一：先上下翻转，再有沿主对角线翻转
> 思路：对于数组的翻转，（90°、180°等），都能转化为两次简单的翻转来实现。
```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        //上下翻转
        for(int i=0;i<n/2;i++){
            for(int j=0;j<n;j++){
                swap(matrix[i][j],matrix[n-1-i][j]);
            }
        }
        //对角线翻转
        for(int i=1;i<n;i++){
            for(int j=0;j<n-i;j++){
                int col = j+i;
                swap(matrix[j][col],matrix[col][j]);
            }
        }

    }
};
```
##### 解法二：原地旋转
> 对于元素(row,col)，旋转90°后到达(col,n-1-row)  
> 对于元素(col,n-1-row)，旋转90°后到达(n-1-row,n-1-col)  
> 对于元素(n-1-row,n-1-col)，旋转90°后到达(n-1-col,n-1-(n-1-row))=(n-1-col,row)  
> 对于元素(n-1-col,row)，旋转90°后到达(row,n-1-(n-1-col))=(row,col)  
> 也就是说，类似于两元素交换，需要用一个temp保存变量，我们用一个temp保存(row,col)后进行四元素的循环交换  
> 对于边长为奇数和边长为偶数两种矩阵，交换的区域有点不同，但实际上可以同时处理（具体见图）   
 
***
<img src="https://assets.leetcode-cn.com/solution-static/48/1.png" alt="p3" height=50% width=50%>
<img src="https://assets.leetcode-cn.com/solution-static/48/2.png" alt="p4" height=50% width=50%>
```c++
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n=matrix.size();
        for(int i=0;i<n/2;++i){
            for(int j=0;j<(n+1)/2;++j){
                int temp = matrix[i][j];
                matrix[i][j]=matrix[n-1-j][i];
                matrix[n-1-j][i]=matrix[n-1-i][n-1-j];
                matrix[n-1-i][n-1-j]=matrix[j][n-1-i];
                matrix[j][n-1-i]=temp;
            }
        }
    }
};
```
