##### 101.对称二叉树
> 给定一个二叉树，检查它是否是镜像对称的
***
##### 解法一：递归
```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return check(root->left,root->right);
    }
private:
    bool check(TreeNode*l,TreeNode*r){
        if(!l && !r)  return true;
        if(!l || !r)  return false;
        if(l->val!=r->val)  return false;
        return check(l->left,r->right)&&check(l->right,r->left);
    }
};
```
##### 解法二：迭代
> 思路：使用一个队列，初始时压入两个root，每次从对列中取出两个元素，如果都为空，continue；如果不相同，返回false；否则将需要比较的两个指针
> 按顺序入队。
```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        queue<TreeNode*> q;
        q.push(root);
        q.push(root);
        while(!q.empty()){
            auto x = q.front();q.pop();
            auto y = q.front();q.pop();
            if(!x&&!y) continue;
            if(!x||!y)  return false;
            if(x->val!=y->val) return false;
            q.push(x->left);
            q.push(y->right);
            q.push(x->right);
            q.push(y->left);
        }
        return true;
    }
};


```
