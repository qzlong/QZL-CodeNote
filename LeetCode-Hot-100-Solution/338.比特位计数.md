##### 338.比特位计数
> 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
***
##### 解法一：动态规划
> 思路：f(n)=n中1的位数，则f(2n)=f(n)，因为2n = n<<1;那f(n)和f(n/2)有什么关系呢？当n是偶数时，f(n)=f(n/2)；
> 当n是奇数时，f(n)=f(n/2)+1；
```c++
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> res(num+1,0);
        for(int i=1;i<=num;++i)
            res[i]=res[i>>1] + (i&1);
        return res;
    }
};
```
##### 解法二：动态规划
> 思路：n&(n-1)可以将n的最低的一个1去除，令f(n)=n中1的个数，则n&(n-1)比n少一个1，且肯定比n小。
> 因此f(n)=f(n&(n-1))+1
```c++
class Solution {
public:
    vector<int> countBits(int num) {
        vector<int> res(num+1,0);
        for(int i=1;i<=num;++i)
            res[i]=res[i&(i-1)] + 1;
        return res;
    }
};
```
