### 42.接雨水
> 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。  
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="p1">  

***
##### 解法一：按行计算(超时)
> 遍历从高度为1到max(height)的每一行，假设当前遍历的是高度N，则高度小于N的可能会积水，高度大于等于N的会让左边可能积水的砖块
> 成功积水。维护一个变量t，当当前高度小于N时，t=t+1；当当前高度大于等于N时，ans+=t，t=0；每次遍历时，当从左往右遇到第一个大于
> N的砖块才会开始维护t，因为只有这也才能蓄住高度为N的水
```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int maxHeight = -1;
        for(auto& h:height){
            maxHeight=max(maxHeight,h);
        }
        int ans=0;
        for(int i=1;i<=maxHeight;++i){
            int start = false;
            int t=0;
            for(auto& h:height){
                if(h>=i){
                    start=true;
                    ans+=t;
                    t=0;
                }else{
                    if(start){
                        ++t;
                    }
                }
            }
        }
        return ans;
    }
};
```
##### 解法二：按列计算
> 思路：针对每一列开始计算，寻找每一列左边和右边最高的列。假设左边最高的列高度为L，右边最高的列高度为R，
> 二者间较短的是S=MIN（L，R），当且列高度为H。那么当前列能蓄水的量则由H和S决定，当S>H时，能蓄水S-H。当S<=H时，当前列无法
> 蓄水。可以用一个数组存储每个位置左边最高的列的高度，然后用一个变量存储右边最高的列的高度，从右往左计算。
```c++
class Solution { //按列计算
public:
    int trap(vector<int>& height) {
        vector<int> L(height.size(),-1);
        for(int i=1;i<height.size();++i){
            L[i]=max(L[i-1],height[i-1]);
        }
        int R=-1,ans=0;
        for(int i=height.size()-1;i>=0;--i){
            int S=min(R,L[i]);
            if(S>height[i])    
                ans+=(S-height[i]);
            R=max(R,height[i]);
        }
        return ans;
    }
};

```
##### 解法三：单调栈
> 利用一个单调栈，当当前高度小于等于栈顶高度时，将当前index入栈；当当前高度大于栈顶高度时，取出栈顶元素，如果栈为空，则
> 将当前坐标入栈，因为栈顶元素无法被左右包围，蓄不住水；否则，比较新栈顶元素的高度和当前高度，取较低值作为高，
> 高与栈顶元素的高的差作为水的高度，当前坐标与栈顶元素的差-1作为水的宽度，ans+=水的面积。
```c++
class Solution { //单调栈
public:
    int trap(vector<int>& height) {
        stack<int> stk;
        int ans=0,current=0;
        while(current<height.size()){
            while(!stk.empty()&&height[current]>height[stk.top()]){
                int h = height[stk.top()];stk.pop();
                if(stk.empty()) break;
                int bound_height = min(height[current],height[stk.top()]);
                int distance = current-stk.top()-1;
                ans+= (bound_height-h) * distance;
            }
            stk.push(current++);
        }
        return ans;
    }
};
```
##### 解法四：双指针
> 设置left和right两个指针，维护两个max_left和max_right分别表示当前的左右最大值。根据解法二，当前列能蓄水的量取决于左右最大值中的
> 最小值。对于left指向的对象，max_left是真实的左边的最大值，但max_right不一定，但如果max_left<max_right，那左右真实的最大值中
> 的最小值一定是当前的max_left，因为真实的max_right只会大于等于当前的max_right。因此当max_left<max_right时，我们就可以
> 处理left，处理完毕后++left。同理，当max_right<=max_left时，处理right，然后--right
```c++
class Solution { //双指针
public:
    int trap(vector<int>& height) {
        
        int left = 0,right = height.size()-1;
        int max_left = 0,max_right = 0;
        int ans = 0;
        while(left<=right){
            if(max_left<max_right){
                ans+=max(0,max_left-height[left]);
                if(height[left]>max_left)
                    max_left=height[left];
                ++left;
            }
            if(max_right<=max_left){
                ans+=max(0,max_right-height[right]);
                if(height[right]>max_right)
                    max_right=height[right];
                --right;
            }
        }
        return ans;
    }
};
```
