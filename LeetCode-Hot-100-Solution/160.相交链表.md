##### 160.相交链表
> 编写一个程序，找到两个单链表相交的起始节点

在C1相交    
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" width = "50%" height = "50%" alt="" align=center />

在8相交  
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" width = "50%" height = "50%" alt="" align=center />

不相交  
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" width = "30%" height = "30%" alt="" align=center />

***
##### 解法一：双指针
> 思路：遍历两个链表，求出长度差diff，然后用两个指针指向两个链表，长的链表先走diff，然后二者同时走，相等时返回
```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int a_len = 0,b_len = 0;
        auto A = headA,B=headB;
        while(A){
            ++a_len;
            A=A->next;
        }
        while(B){
            ++b_len;
            B=B->next;
        }
        int distance = abs(b_len-a_len);
        auto longList = a_len>b_len?headA:headB;
        auto shortList = a_len>b_len?headB:headA;
        for(int i=0;i<distance;i++)
            longList = longList->next;
        while(longList!=shortList){
            longList=longList->next;
            shortList=shortList->next;
        }
        return longList;
    }
};
```
##### 解法二：双指针
> 思路：两个指针指向两个链表，同时走，当其中一个指针走完后，移动到另一个链表的头部，若在某时刻相遇，则说明PA/PB为相交节点
> 这样为什么可行？很简单，因为链表A的长度+链表B的长度等于链表B的长度+链表A的长度，因此二者肯定同时到达终点（不管是null还是确实有终点）
> 同时到达终点意味者如果有交点的话也会同时到达交点（因为交点之后的部分就是两个链表共享的）
```c++
class Solution{
    public:
        ListNode* getIntersectionNode(ListNode* headA,ListNode* headB) {
            auto *pa = headA,*pb = headB;
            if(!pa||!pb)    
                return nullptr;
            while(pa!=pb){
                pa = pa == nullptr? headB : pa->next;
                pb = pb == nullptr? headA : pb->next;
            }
            return pa;
        }
};
```





